---
layout: essay
type: essay
published: true
title: "Don't Reinvent the Wheel: Why to Use Design Patterns"
date: 2017-12-05
labels:
  - Design Patterns
---

<img class="ui fluid image" src="../images/reinventing-the-wheel.jpg">

If I were to just analyze the phrase “design patterns”, I might deduce that “design” deals with how something is constructed and built while “patterns” relates to commonalities observed over time that consistently work well. This isn’t far from the truth: Design patterns are essentially time-tested solutions that work effectively in solving common recurring problems. To not use design patterns would be idiomatically equivalent to trying to reinvent the wheel — a waste of time and energy in trying to create from scratch what has already been perfected and tested. In the following paper I will highlight a few common design patterns including the Factory, Singleton, Model-Viewer-Controller, and Observer patterns — as well as provide some everyday analogies and some instances where I have used them in my code projects.

The idea behind the Factory design pattern is to give the receiving client options. My brother and I shared a twin-size bunk bed most of our lives: Part of its manufactured design was the ability to reposition the ladder that went up to the top bed depending on the bed’s setup in the room. Additionally, the ladder could be entirely removed and the top and bottom bunks could be separated to form two independent beds. These features were designed to allow the consumer to change the setup of the bunk bed, and this is essentially how the Factory design pattern works. I’ve used this many times when coding polymorphic class in Java and C++, where I would create a parent class (say, a spaceship class) which could later be instantiated as a child class (like a Millennium Falcon class).

The Singleton design pattern allows a single instance of some object to be available and unique everywhere. The Guinness World Record organization performs a similar function in recording world records, ensuring that only one record holder is recognized at a time. Anyone who wants to know the holder of a record refers to the Guinness Book of World Records as the single definitive source, and while the actual record holder may change the Book as the global source will not. While the Singleton design pattern can be useful in creating global variables, I personally have not used it in any coding projects. I do know that my software engineering professor found a rather ingenious implementation of Singleton in creating an instance of a data collection and then exporting it as a constant variable to be used in other parts of the program. Any program file that needed to access that specific collection instance could then just import the variable.

Next up is the Model-Viewer-Controller (MVC) design pattern, though I’ve also heard it by other names. The idea behind this pattern is interpreting what a user wants and presenting the appropriate response from data. Think of it like one of those drink vending machines that only display pictures of the drinks rather than a clear-glass view of the current inventory. The customer presses the image for the drink they want, and the machine interprets the action and finds the right drink. Once found, the drink delivers the drink to the customer. The MVC design pattern functions similarly, receiving user actions and determining what information to display in response. On a video game networking site project my team used MVC in controlling the initial progression of pages a visiting user would be presented with: If the program detected that the user was a first timer with no existing profile stored in the database, the site would redirect them to an account creation page, after which the user would be shown the main home dashboard. If the user already had a profile, the site would go directly to the home page.

The final design pattern is the Observer pattern, and its concept is fairly straightforward: A central information source notifies select dependents when relevant information has been changed. A very common example of this today is YouTube. If viewers want to be notified when a new video is uploaded, they can subscribe to respective the channels. Instead of YouTube sending notifications to all viewers every single time a new video of any kind is uploaded, viewers are only notified when the channels they are subscribed post new uploads. The same video game networking site I mentioned earlier includes a endorsement system called “commendations”. After finishing a game, gamers have the opportunity to give other gamers commendations depending on how well they played (e.g. good sniper, communicator, strategist, etc.). Each commendation has a counter to keep track of how many people have given that player the same commendation. This count is then displayed on the player’s profile page and in the directory search. Rather than update every profile in the directory, I used the Observer design pattern to only update that one individual’s profile. Makes sense right?
